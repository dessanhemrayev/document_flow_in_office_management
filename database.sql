CREATE DATABASE  IF NOT EXISTS `otdel_kadr` /*!40100 DEFAULT CHARACTER SET utf8 */ /*!80016 DEFAULT ENCRYPTION='N' */;
USE `otdel_kadr`;
-- MySQL dump 10.13  Distrib 8.0.22, for Win64 (x86_64)
--
-- Host: localhost    Database: otdel_kadr
-- ------------------------------------------------------
-- Server version	8.0.22

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!50503 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `document`
--

DROP TABLE IF EXISTS `document`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `document` (
  `id` int NOT NULL AUTO_INCREMENT,
  `type_doc` varchar(145) NOT NULL,
  `document` longtext NOT NULL,
  `date` date NOT NULL,
  `id_to_whom` int NOT NULL,
  `users_id` int NOT NULL,
  PRIMARY KEY (`id`),
  KEY `fk_document_users_idx` (`users_id`),
  CONSTRAINT `fk_document_users` FOREIGN KEY (`users_id`) REFERENCES `users` (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `document`
--

LOCK TABLES `document` WRITE;
/*!40000 ALTER TABLE `document` DISABLE KEYS */;
INSERT INTO `document` VALUES (1,'Заявление','МИНОБРНАУКИ РОССИИ\nФедеральное государственное бюджетное образовательное\nучреждение высшего образования\n«Юго-Западный государственный университет»\n(ЮЗГУ)\nКафедра Информационной безопасности\n\n\n\nЛабораторная работа №4\nпо дисциплине «Инженерно-техническая защита информации» \n\n\n\nВыполнил:							студент группы ИБ-71б\n                  Хемраев Д.\n\nПроверил	                              	                               Калуцкий И.В.\n                                                  \n\n\n\nКурск, 2020\nЦель работы\nИзучение устройства и основных режимов работы универсального прибора для обнаружения устройств скрытого съема информации СРМ-700, а также выработка практических навыков при обследовании помещения прибором СРМ-700 при использовании РЧ-зонда.\nТеоретическая часть.\nУстройство и характеристики прибора СРМ-700. СРМ-700 является универсальным исследовательским приспособлением, которое может использоваться для обнаружения и локализации широкого разнообразия устройств наблюдения.  Устройства наблюдения используют несколько способов захвата информации и доставки ее к злоумышленнику. Жучок может передавать информацию по средством РЧ излучения, или может пересылать ее по обычным линиям питания или телефонным линиям. Информация может быть аналоговой (модулирована в сигнал) или цифровой (представлена в виде последовательности 0 и 1). СРМ -700 помогает Вам определить, какие сигналы являются легальными и безопасными, а какие угрожают Вашей безопасности. \nВ стандартную комплектацию СРМ-700 входит:\n•	Зондовое исследовательское устройство против наблюдения и прослушивания СРМ -700 \n•	Стандартный РЧ зонд (50кГц-3ГГц) \n•	Зонд для очень НЧ несущего тока \n•	ТВНЧ кабель \n•	Вспомогательный кабель \n•	Наушники \n•	Мягкий кейс для транспортировки\nСтандартный комплект позволяет проводить поиск радиопередающих подслушивающих устройств в диапазоне 50 кГц-3 ГГц(радиочастоты, радиотелефоны, протокол беспроводных сетей),а так же обследование проводных линий.  Стандартный радиочастотный зонд RFP-700 представлен на рисунке 1. Позволяет выявлять акустические и телефонные радиопередатчики, видеопередатчики, цифровые передатчики с шумоподобным спектром, изменяющейся частотой, в диапазоне до 3 ГГц.\n\nРис.1-РЧ-зонд\nЛицевая панель представлена на рисунке 2, где номерами отмечены основные компоненты устройства.\n \nРис.2-Лицевая панель\nPHONES (1):Для использования наушников и одновременного отключения внутреннего громкоговорителя.\nGAIN (2): Регулирует усиление звука (громкость) на громкоговорителе или выходе для наушников. Не влияет на уровень сигнала на выходе для записи.\nFILTER (3): Действует как полосовой фильтр в полосе речевых частот от 500 Гц до 2,5 кГц, убирает большую часть шума переменного тока на дополнительном входе и \"видео” шума на входе для радиочастотного зонда. Фильтр обрабатывает звуковые сигналы как для выхода на наушники, так и для выхода на запись. Дисплей отображает работу фильтра (IN (включен) или OUT(выключен)).\nMODE (4): Устанавливает прибор либо в режим поиска(SEARCH), либо в режим мониторинга(MONITOR).Режим поиска применяется при методичном\nобследовании помещения. Режим мониторинга применяется после поиска для постоянного отслеживания появления новых устройств. Дисплей показывает активацию режима (SEARCH или MONITOR).\nSILENT/TONE (5): Выключает звуковой сигнал при срабатывании тревоги. Красный светодиод продолжает гореть. Дисплей отображает, в каком режиме находится СРМ (TONE или SILENT).\nTHRESHOLD (6): Устанавливает мигающий сегмент на ЖК-дисплее на выбранной позиции. Когда значение входного сигнала превышает уровень, выставленный с помощью мигающего сегмента, прибор переключается в режим тревоги и активирует выход дистанционного управления. THRESHOLD является активным только в режиме MONITOR.\nALERT (7): Красный светодиод загорается при срабатывании тревоги.\nINPUT LEVEL (8): Отображает уровень входного сигнала с зонда или дополнительного входа; полулогарифмическая шкала с двумя диапазонами чувствительности.\nPULSING SEGMENT (9): Мигающий сегмент, устанавливает порог срабатывания сигнала тревоги в режиме мониторинга.\nSTATUS DISPLAY (10): Показывает текущие положения органов управления и используемый вход.\nPROBE (11): Входной разъем для подключения зондов. Через него также идет питание для зондов. При присоединении зона к прибору он автоматически переключается на этот вход.\nGAIN (12): Изменяет чувствительность шкалы индикатора и аудиоусилителя. В положении HIGH обеспечивается дополнительное усиление слабых входных сигналов. Дисплей показывает выбранный режим чувствительности HIGH(высокий), или LOW (низкий).\nПодготовка РЧ-зонда к работе\nСледующие процедуры применяются при каждом подключении РЧ-зонда.\n1. Подключите наушники, выставите минимальное усиление звука (против часовой стрелки).\n2. Поставьте переключатель режимов (Mode Switch) В позицию Search.\n3. Присоедините РЧ-зонд к зондовому входу прибора (Рrоbе) и разверните антенну на полную длину.\n4. Включите питание прибора и убедитесь в активации прибора.\n5. Установите уровень усиления. Если на дисплее индицируется высокий уровень шума (более 10 сегментов), то надо переключиться на низкий (1ow)\nуровень усиления и, если необходимо, укоротите\nантенну. Настройте усиление звука до удобного уровня.\nПоследовательность действий при поиске.\n1. Одев наушники и взяв радиочастотный зонд за поролоновую ручку, устанавливаем его вертикально перед собой, перед входом в обследуемое помещение.\n2. Войдя в помещение, оцениваем средний уровень сигнала на индикаторе. Используя снижение усиления “LOW”, если дисплей показывает максимальное значение “MAX”. Укорачиваем антенну, если дисплей показывает “MAX” при усилении “LOW”\n3. Поворачиваемся на 360 градусов вокруг, следя за показаниями дисплея, они будут меняться в зависимости от направления на источник сигнала.\n4.Выделяем направление с максимальным уровнем сигнала.\n5. Обследуем все объекты, в которых могут быть спрятана “закладка”. Если\n“закладка” рядом, то показания дисплея будут расти (в случае необходимости переключаем усиление на “LOW”).\n6.Выключаем все приборы и свет в зоне контроля и близ нее и посмотрите, не изменились ли показания дисплея. Иногда обычная лампа создает очень сильные радиопомехи, в таком случае она должна быть выключена или удалена из комнаты. Если изменения в показаниях дисплея не могут быть вызваны такими явными причинами, то это означает реальное подозрение на \"закладку\".\n7.Необходимо идентифицировать выявленный источник радиоизлучения с \nцелью отделить сигнал закладки от \"нормального\" сигнала. Обнаружение сигнала \"известного звука\" (звуковые помехи напоминающие, помехи в колонках при близком радиосигнале мобильного устройства) означает обнаружение “закладки ”.\nХод работы:\nПри проведении данной лабораторной работы происходила закладка устройства в аудитории. С помощью СРМ-700 необходимо обнаружить местонахождение устройства. \nПри вхождении в аудиторию, держа РЧ зонд за рукоятку, я обнаружил наличие шумов. После чего произвел настройку уровня усиления. При тщательном осмотре аудитории появился характерный звук в некоторой области.  Путем медленного перемещения радиозонда в том направлении и поворота на небольшой угол, я выяснил приблизительное направление движения. Я продолжил движение в направлении характерного звука, вследствие чего обнаружил радиозакладку. \nПри поиске устройства возник ряд трудностей, а именно: помехи от окружающих устройств. \nВывод: в ходе работы изучено устройство и основные режимы работы универсального прибора для обнаружения устройств скрытого съема информации СРМ-700, а также проведено обследовании помещения прибором СРМ-700 при помощи РЧ-зонда. Основные проблемы, с которыми столкнулись во время поиска: работа в диапазоне от 50 кГц до 3ГГц (широкий спектр радиоизлучений); посторонние помехи, достаточное количество техники (компьютеры, телефоны и т.д.) создающее дополнительные помехи, СРМ-700 должен очень близко находиться к закладке. ','2020-11-17',5,3),(2,'Договор','МИНОБРНАУКИ РОССИИ  \nФедеральное государственное бюджетное образовательное учреждение высшего образования\n  \n«Юго-Западный государственный университет»  \nКафедра информационной безопасности  \n  \nОсновы риверсинжениринга программных средств  \n  \n  \nЛабораторная работа №3\n \n  \n  \n  \n  \n  \n  \n  \nВыполнил:   	студент группы ИБ-81б  \n  	Пайгамов Д \nПроверил:  	доцент  \n  	Марухленко А.Л.   \n  \n \nКурск, 2020  \n\nЦель работы: 		\n\nТребуется реализовать игру «Угадай число». Программа \"загадывает\" целое число от 0 до 100, пользователь пытается угадать его, вводя числа в соответствии с подсказками программы. Метод половинного деления, применяемый пользователем, позволяет \"угадывать\" числа за мин. к-во попыток (7 попыток для диапазона 1-100).\nНеобходимое ПО: Android studio, эмулятор либо реальное Android устройство.\n\nХод работы:\n\nДля создания проекта необходимо установить ПО Android Studio (https://developer.android.com/studio). На рисунке 1 представлен выбор шаблона при создании проекта.\n\n\nРис.1 – Создание проекта под приложение\n\nРисунок 2 – Процесс редактирования внешнего вида главного окна приложения\n\nПосле добавления элементов дизайна стартового окна игры (рисунок 2), необходимо расположить их в правильном порядке, благодаря вкладке дерево компонентов (Component tree, рисунок 3).\n\n\nРисунок 3 – Настройка дерева компонентов\n\nАналогичные манипуляции были произведены и с основным игровым окном (рисунок 4).\n\nРисунок 4 – Добавление второго окна\n\nПереключение на окно с игровым процессом осуществляется посредством нажатия кнопки и представлено на рисунке 5 в виде кода.\n\n\nРисунок 5 – Исходный код стартового окна приложения\n\nСам процесс игры и вывод результата реализован с использованием так называемых тостов. Тост – это всплывающее уведомление с информацией о той или иной операции. Он занимает минимум места, не отвлекая пользователя от текущего действия и не нарушая работоспособность приложения. По истечении тайм-аута тост автоматически исчезает.\n\nРисунок 6 – Участок кода, реализующий процесс игры\n\n\nРисунок 7 – Тестирование приложения\n\nТестирование приложение с помощью встроенного в Android Studio эмулятора телефона изображено на рисунке 7.\nВывод: \n\nБыли получены практические навыки по установке, настройки и работе с Android Studio, а также подключение эмуляторов мобильных устройств для тестирования разработанных приложений. Изучены основы построения графических приложений с использованием вышеупомянутого ПО. В ходе выполнения лабораторной работы была реализована игры «Угадай число» и протестирована ее работоспособность на базе мобильных устройств с дисплеем 5-дюймового разрешения под управлением операционной системы Android версии 7.0.','2020-11-17',3,5),(3,'Приказ','МИНОБРНАУКИ РОССИИ  \nФедеральное государственное бюджетное образовательное учреждение высшего образования\n  \n«Юго-Западный государственный университет»  \nКафедра информационной безопасности  \n  \nОсновы риверсинжениринга программных средств  \n  \n  \nЛабораторная работа №3\n \n  \n  \n  \n  \n  \n  \n  \nВыполнил:   	студент группы ИБ-81б  \n  	Пайгамов Д \nПроверил:  	доцент  \n  	Марухленко А.Л.   \n  \n \nКурск, 2020  \n\nЦель работы: 		\n\nТребуется реализовать игру «Угадай число». Программа \"загадывает\" целое число от 0 до 100, пользователь пытается угадать его, вводя числа в соответствии с подсказками программы. Метод половинного деления, применяемый пользователем, позволяет \"угадывать\" числа за мин. к-во попыток (7 попыток для диапазона 1-100).\nНеобходимое ПО: Android studio, эмулятор либо реальное Android устройство.\n\nХод работы:\n\nДля создания проекта необходимо установить ПО Android Studio (https://developer.android.com/studio). На рисунке 1 представлен выбор шаблона при создании проекта.\n\n\nРис.1 – Создание проекта под приложение\n\nРисунок 2 – Процесс редактирования внешнего вида главного окна приложения\n\nПосле добавления элементов дизайна стартового окна игры (рисунок 2), необходимо расположить их в правильном порядке, благодаря вкладке дерево компонентов (Component tree, рисунок 3).\n\n\nРисунок 3 – Настройка дерева компонентов\n\nАналогичные манипуляции были произведены и с основным игровым окном (рисунок 4).\n\nРисунок 4 – Добавление второго окна\n\nПереключение на окно с игровым процессом осуществляется посредством нажатия кнопки и представлено на рисунке 5 в виде кода.\n\n\nРисунок 5 – Исходный код стартового окна приложения\n\nСам процесс игры и вывод результата реализован с использованием так называемых тостов. Тост – это всплывающее уведомление с информацией о той или иной операции. Он занимает минимум места, не отвлекая пользователя от текущего действия и не нарушая работоспособность приложения. По истечении тайм-аута тост автоматически исчезает.\n\nРисунок 6 – Участок кода, реализующий процесс игры\n\n\nРисунок 7 – Тестирование приложения\n\nТестирование приложение с помощью встроенного в Android Studio эмулятора телефона изображено на рисунке 7.\nВывод: \n\nБыли получены практические навыки по установке, настройки и работе с Android Studio, а также подключение эмуляторов мобильных устройств для тестирования разработанных приложений. Изучены основы построения графических приложений с использованием вышеупомянутого ПО. В ходе выполнения лабораторной работы была реализована игры «Угадай число» и протестирована ее работоспособность на базе мобильных устройств с дисплеем 5-дюймового разрешения под управлением операционной системы Android версии 7.0.','2020-11-17',3,5),(4,'Договор','СОДЕРЖАНИЕ\n\nВВЕДЕНИЕ\n1. ПРОЕКТИРОВАНИЕ БАЗЫ ДАННЫХ\n1.1	Построение логической модели\n1.2 Построение физической модели\n2. РАЗРАБОТКА ПРИЛОЖЕНИЯ ПРИ РАБОТЕ С БАЗОЙ ДАННЫХ\n2.1 Назначение\n2.2 Структура приложения\n2.3 Описание приложения\n2.4 Тестирование приложения\n2.5 Руководство пользователю\nЗАКЛЮЧЕНИЕ\nСПИСОК ИСПОЛЬЗОВАННЫХ ИСТОЧНИКОВ\nПРИЛОЖЕНИЕ\n\nВВЕДЕНИЕ\n\nРеляционная база данных — база данных, основанная на реляционной модели данных. Так что же такое реляционная база данных? Это таблица, в которой в качестве столбцов выступают имена хранимых в ней данных, а каждая строка содержит сами данные.\nВ зависимости от расположения программы, использующей данные, и самих данных, а также способа разделения данных между несколькими пользователями различают локальные и удаленные базы данных. Данные локальной базы данных (файлы данных) находятся на одном (локальном) устройстве, в качестве которого может выступать диск компьютера или сетевой диск. Данные (файлы) удаленной базы данных находятся на удаленном компьютере. Программа работы с удаленной базой данных состоит из двух частей: клиентской и серверной. Клиентская часть программы, работающая на компьютере пользователя, обеспечивает взаимодействие с серверной программой: посредством запросов, передаваемых на удаленный компьютер, предоставляет доступ к данным. Серверная часть программы, работающая на удаленном компьютере, принимает запросы, выполняет их и пересылает данные клиентской программе. Удалённые базы данных рассматриваться не будут в рамках данного курсового проекта.\n\n\n1. ПРОЕКТИРОВАНИЕ БАЗЫ ДАННЫХ\n\nБаза данных — это набор файлов (таблиц), в которых находится информация. Как правило, база данных состоит из нескольких таблиц, которые размещают в одном каталоге. Таблицу можно создать, воспользовавшись входящей в состав Delphi утилитой Borland Database Desktop или организовав SQL-запрос к серверу базы данных. Для доступа к файлам (таблицам) базы данных библиотека BDE использует не имя каталога, в котором находятся файлы, а его псевдоним. Перед тем, как приступить к созданию таблиц новой базы данных, необходимо создать псевдоним для этой базы данных. Процесс создания базы данных может быть представлен как последовательность следующих шагов:\n·	создание каталога;\n·	создание псевдонима;\n·	создание таблиц;\nКаталог (папка) для файлов базы данных создается обычным образом, например, при помощи Проводника.\nПсевдоним базы данных создается при помощи входящей в Delphi утилиты BDE Administrator, которая запускается из Windows выбором из меню Программы | Borland Delphi 7 команды BDE Administrator.\nПри создании псевдонима по умолчанию предлагается драйвер STANDARD (default driver), который обеспечивает доступ к таблицам в формате Paradox. После этого нужно изменить автоматически созданное администратором имя псевдонима и задать путь к файлам базы данных, для которой создается псевдоним.\nПуть к файлам базы данных можно ввести на вкладке Definition в поле Path с клавиатуры или воспользоваться стандартным диалоговым окном Select Directory (Выбор каталога), которое открывается щелчком на кнопке с тремя точками, находящейся в конце поля Path.\nВажным моментом при создании базы данных является распределение информации между полями записи. Очевидно, что информация может быть распределена между полями различным образом.\n\n1.1	Построение логической модели\n\nЛогическое проектирование базы данных (также называемое построением ее логической модели) представляет собой процесс объединения данных в логически организованные группы объектов, которые можно легко поддерживать.\nСоздаваемая база данных «Отдел кадров» по условию курсовой работы должна содержать три таблицы: Сотрудники, Подразделения, Рабочие места. Для построения логической модели будем использовать программу ERWin. Логическая модель представлена на рисунке 1.1:\n\n\nРисунок 1.1 – Логическая модель базы данных111\n\n1.2 Построение физической модели\n\nНа этапе построения физической модели начинается непосредственное проектирование базы данных с использованием средств Delphi.Физическая модель данных является продолжением создания нашей базы данных.\nДля создания базы данных для начала необходимо создать псевдоним (Alias) — это короткое имя, поставленное в соответствие реальному, полному имени каталога базы данных. Вызов этой программы осуществляется из главного меню Delphi команде Database / Explore. Создаем свой псевдоним. Для этого в окне SQL Explorer на вкладке DataBases выбираем Object/ New. В результате данных манипуляций появится окно представленное на рисунке 1.2.1:\n\n\nРисунок 1.2.1 – Вид окна New Database Alias\n\nНажимаем и в окне SQL Explorer появляется новый псевдоним STANDARD1 , которому присваиваем другое имя – DBCadr. Далее указываем путь к папке, где находятся таблицы базы данных используемых в нашей работе. Для этого нажимаем пиктограмму с тремя точками напротив надписи PATH и указываем путь. Щелкаем правой кнопкой мыши и в контекстном меню выбираем Apply. Псевдоним создан. Результат создания псевдонима представлен на рисунке 1.2.2:\n\n\nРисунок 1.2.2 - Создание псевдонима\n\nИтак, псевдоним создан. Далее необходимо создать непосредственно сами таблицы, в которых будут храниться наши данные. Для того, чтобы создать таблицу необходимо выбрать Меню->Tools->Database Desktop. Для создания новой таблицы выбрать File->New->Table. Появится окно выбора типа базы данных Create Table (Рисунок 1.2.3). По умолчанию уже выбран тип таблиц Paradox, поэтому нажимаем ОК.\n\n\nРисунок 1.2.3 – Вид окна Create Table\n\nПосле этого на экране появится окно для создания и редактирования структуры таблицы Create Paradox 7 Table (Рисунок 1.2.4).\n\n\nРисунок 1.2.4 – Окно создания структуры таблицы Paradox\n\nДалее в нашей работе для каждого поля таблицы необходимо зададим имя, тип и размер. Имя поля используется для доступа к данным. В качестве FieldName — идентификатора поля используется латинский алфавит до 25 символов и цифры. Затем надо выбрать тип (Туре) данных этого поля. Для этого нужно перейти в раздел Туре поля и щелкнуть правой кнопкой мыши. Появится список доступных типов, из которого можно выбрать необходимый. Также задаём размер наших полей и определяем, какие из них будут ключевыми. После нажимаем на кнопку Save As и указываем путь, куда сохранить созданную таблицу.\nИмена полей таблиц для данной работы и их типы приведены на представленных ниже рисунках 1.2.5-1.2.9.\n\n\nРисунок 1.2.5 – Структура таблицы «Сотрудники»\n\n\nРисунок 1.2.6 – Структура таблицы «Рабочие места»\n\n\nРисунок 1.2.7 – Структура таблицы «Подразделения»\n\nДля удобства заполнения таблицы можно использовать маски (шаблоны). Для этого будем использовать поле Picture, которое позволяют задать шаблон. Используя его можно контролировать правильность вводимой в поле информации. Шаблон представляет собой последовательность обычных и специальных символов. На рисунке 1.2.5 можно увидеть, что для поля адрес использована маска - г. &*~ ул. &*~ д. *# кв. *# . Для ввода фамилии и инициалов - &*~ (первая буква прописная, остальные строчные),табельного номера - ##### , где (#-цифра). После ввода маски (маски можно и не вводить) нажимаем кнопку Save.\nОткрыв раскрывающийся список Table properties, выберем раздел Secondary Indexes. В этом разделе мы задаем индексированные поля. Индексированные поля – поля по которым чаще всего осуществляется поиск и сортировка. Из окна Fields выбираем поле Fam, для которого задается индекс, нажимаем на стрелку вправо и установим переключатель Maintained, как показано на рисунке 1.2.8.\n\n\nРисунок 1.2.8 – Окно установки вторичных индексов\n\nЗатем нажимаем ОК и сохраняем под именем указанном на рисунке 1.2.9.Данные действия выполняются для сортировки по возрастанию.\n\n\n\nСнова нажмём Define и из окна Fields выбираем поле Fam, для которого задается индекс, нажимаем на стрелку вправо и установим переключатель в Descending (для сортировки по убыванию) и сохраним под именем FamIndDes. В данной таблице создадим аналогично вторичные индексы для поля табельный номер. В результате поля стали индексированными.\nЗаполняем таблицу данными. Заполненную таблицу «Сотрудники» можно увидеть на рисунке 1.2.10.\n\n\nРисунок 1.2.10 – Заполненная таблица «Сотрудники»\n\nАналогично создаём таблицы «Рабочие места» и «Подразделения». Структуру этих таблиц и сами заполненные таблицы изображены на рисунках 1.2.11 – 1.2.12. В таблице «Рабочие места» присутствует маска в поле номер места - ###, вторичные индексы – должность и номер места. В таблице «Подразделения» маска в поле табельный номер - #####, а вторичные индексы в полях – табельный номер, название подразделения и номер места, как описано выше (аналогично предыдущим).\n\n\n\nРисунок 1.2.11 – Заполненная таблица «Рабочие места»\n\n\nРисунок 1.2.12 – Заполненная таблица «Подразделения»\n\nПо необходимости на значения полей можно накладывать ограничения по максимальному и минимальному значению это можно сделать в свойствах таблицы Validity Checks — проверка правильности значений.\nНажав кнопку Assist можно проверить правильность функционирования маски, к примеру, для ввода адреса в таблице «Сотрудники». Результат выполнения представлен на рисунке 1.2.13.\n\nРисунок 1.2.13 – Окно проверки функционирования маски\nбаза данные серверный программа\nРассмотрим свойство таблицы Referential Integrity — целостность на уровне ссылок. Речь идет о способах, позволяющих обеспечить постоянные связи между данными отдельных таблиц. Если устанавливается целостность на уровне ссылок между двумя таблицами, одна из которых — главная (родительская), а другая — вспомогательная (дочерняя), то во вспомогательной таблице указывается поле (или группа полей), которые могут брать свои значения только из ключевого поля (или полей) головной таблицы. В списке fields выбирается поле связи редактируемой таблицы (дочерняя), а в списке table указываем родительскую таблицу. Результат выполнения связи для таблиц «Подразделения» и «Сотрудники» представлен на рисунке 1.2.14, аналогично и для таблицы «Рабочие места».\n\n\n\nРисунок 1.2.14 – Установление ссылочной целостности\n2. РАЗРАБОТКА ПРИЛОЖЕНИЯ ПРИ РАБОТЕ С БАЗОЙ ДАННЫХ\n\nРазмещение компонентов на форме для работы с базами данных.\nКаждое приложение, использующее базы данных, обычно имеет, по крайней мере, по одному компоненту следующих трех типов:\n• Компоненты — наборы данных (data set), непосредственно связывающиеся с базой данных. Для BDE это такие компоненты, как Table, Query.\n• Компонент — источник данных (data source), осуществляющий обмен информацией между компонентами первого типа и компонентами визуализации и управления данными. Таким компонентом является Data Source.\n• Компоненты визуализации и управления данными, такие, как DBGrid,\nDBText, DBEdit и множество других.\nКомпонент DataSource находится на вкладке DataAccess, компоненты Table и Query расположены на вкладке BDE, компоненты DBNavigator и DBGrid размещены на вкладке Data Controls.\n\n2.1 Назначение\n\nПриложение по работе с базами данных необходимо для организации работы с данными, представленными в базе. Данное приложение, согласно заданию курсового проекта, предназначено для удаления и добавления новых данных, поиска по заданному критерию, а также создания вычисляемых полей.\n\n2.2 Структура приложения\n\nПриложение состоит из программы для отображения, добавления, редактирования и удаления информации локальной базы данных и самой локальной базы данных, предусмотрен поиск по заданному критерию, рассмотрено создание вычисляемых полей. Тип базы данных – реляционная база данных Paradox v.7.\nВ приложении для работы с базами данных будем использовать две форма: первая - для отображения таблиц данных и сортировок, вторая - для поиска. На первой форме размещены три компонента DBGrid, в которых будут отображаться таблицы, созданные в DataBase Desktop, три компонента Table для набора данных, а также три компонента DataSource, которые будут являться источниками данных. Компоненты DBNavigator для упрощения работы с таблицами (удаления, добавления и так далее). Компонент Query, который понадобится для организации поиска. Также на форме расположенные компоненты RadioGroup и GroupBox, на которых находятся переключатели RadioButton, определяющие вид сортировки (то есть поля сортировки) и её направление. И кнопки, которым приписываются функции поиска, обновления данных, сортировки и выхода из приложения.\nНа второй форме располагаются компоненты ComboBox – выбор критерия поиска, Edit - для ввода информации и кнопка закрытия формы.\n\n2.3 Описание приложения\n\nОткрываем приложение и переносим на форму необходимые компоненты. Три компонента Table со страницы библиотеки ВDЕ. Перенесим также на форму со страницы Data Access три компонента DataSource, которые будут являться источником данных. Оба эти компоненты невизуальные, пользователю они будут не видны, их можно разместить в любом месте формы. В качестве компонента визуализации данных возьмем компонент DBGrid со страницы Data Controls. Это визуальный компонент, в котором будут отображаться данные формы.\nТеперь нам надо установить цепочку связей между этими компонентами. Главное свойство DBGrid и других компонентов визуализации и управления данными — DataSource. Выделяем на форме компонент DBGrid l и щелкаем по его свойству DataSource в Инспекторе Объектов. Появляется список, в котором перечислены все имеющиеся на форме источники данных. В нашем случае источником данных является DataSource l. Далее необходимо установить связь между источником данных и набором данных. Выделяем компонент DataSource l и найдем в Инспекторе Объектов его главное свойство — DataSet. Теперь нажмем на этом свойство и из выпадающего списка выберираем Tablel . Теперь осталось связать компонент Tablel с необходимой таблицей базы данных.\nДля компонента Table1 в инспекторе объектов необходимо изменить следующие свойства:\n·	Свойство DatabaseName имеет тип String и задает полный путь к каталогу базы данных. В значении этого свойства можно указать вместо пути к каталогу базы данных ее псевдоним. Укажем псевдоним – DBCadr.\n·	Свойство TableName имеет тип TFileName и определяет имя файла таблицы базы данных, которую инкапсулирует объект. Укажем – Sotrudniki.db.\nАналогичные действия выполняем и для оставшихся компонентов и таблиц. Теперь можно прямо в процессе проектирования соединиться с базой данных. Соединение осуществляется свойством Active. По умолчанию оно равно false. Устанавливаем его в true и в поле компонента DBGridl стали данные из таблицы. Аналогично и для других таблиц. В спроектированное приложение добавляем еще один компонент, управляющий работой с таблицей - навигатор DBNavigator, расположенный на странице Data Cortrols и помещаем его на форму. Для компонента DBNavigator1 необходимо изменить свойство DataSource: (указывает источник данных для набора данных). Укажем – DataSource1. Компонент имеет ряд кнопок, служащих для управления данными. Назначения кнопок приведены в таблице 2.3.1.\n\n\nТаблица 2.3.1 Назначение кнопок компонента DBNavigator\nКнопки	Назначение\nnbFirst	перемещение к первой записи\nnbPrior	перемещение к предыдущей записи\nnhNext	перемещение к следующей записи\nnbLast	перемещение к последней записи\nnblnsert	вставить новую запись перед текущей\nnbDelеte	удалить текущую запись\nnbEdit	редактировать текущую запись\nnbPost	послать отредактированную информацию в базу данных\nnbCancel	отменить результаты редактирования или добавления новой записи\nnbRefresh	очистить буфер, связанный с набором данных\n\nПомещаем Query1 на форму, он необходим для функции поиска в приложении. В Инспекторе Объектов данного компонента находим свойство DataBaseName, в нём указываем используемый нами псевдоним DBCadr.\nПоместим на форму кнопки «Поиск», «Обновить таблицы», «Выход», «Сортировка» и для каждой в обработчике события напишем соответствующие процедуры.\nДля того, чтобы в наших таблицах название полей отображалось на русском языке выберем компонент Table. Двойной щелчок мыши по данному компоненту вызывает редактор полей. Правой кнопкой мыши вызываем контекстное меню редактора и выбираем меню «Add fields…»и в результате получаем:\n\n\nРисунок 2.3.1 – Редактор полей\n\nВыбираем в редакторе полей поле, которое желаем переименовать, и в инспекторе объектов меняем значение свойства DisplayLabel .\nДля создания вычисляемого поля также используем редактор полей. В нашем случае выбираем: Table3/ Fields Editor/New field. Появится диалоговое окно представленное на рисунке 2.3.2.\n\n\nРисунок 2.3.2 - Диалоговое окно New field\n\nВ поле Name вводим название вычисляемого поля – Sum , а также указываем его тип Currency, в разделе Field type ставим переключатель напротив Calculated, нажимаем «Ок». Далее выбираем компонент Table3 и в Инспекторе Объектов в разделе события выбираем OnCalcFields и пишем соответствующую процедуру. В ней для данных таблицы «Подразделения» будем вычислять сумма оклада и процента надбавкиа:\nTable3Sum.Value:=Table3Oklad.Value+Table3Oklad.Value*Table3Nadbavka.Value/100;\nТеперь для того, что бы при выборе по определенному критерию в одной из таблиц, мы могли бы получить информацию из других таблиц мы свяжем таблицы прямо на форме. Для этого выбираем на форме Table3 и в Инспекторе Объектов свойство Master Source и указываем источник данных - DataSource 2, а через MasterFields указываем поля связи. Данная процедура отражена на рисунке 2.3.3. Аналогично связываем таблицу «Сотрудники» с таблицей «Подразделения».\n\n\nРисунок 2.3.3 – Процедура связи таблиц по ключевым полям\n\nДалее опишем формирование SQL –запроса. Для доступа к запросу на первой форме поместим кнопку «Поиск», а на второй форме создадим поля для ввода данных запроса и поместим компонент ComboBox (свойство Items и ItemIndex) для выбора критерия запроса. Окно поиска представлено на рисунке 2.3.4.\n\n\nРисунок 2.3.4 – Окно поиска по заданному критерию\n\nВыбираем Query1 и в Инспекторе объектов выбираем свойство SQL: TStrings, двойным щелчком мыши вызываем диалоговое окно, где оформляем запрос, более подробно формируется программным образом (рисунок 2.3.5).\n\n\nРисунок 2.3.5 – Формирование SQL –запроса\n\nВ общем виде запрос выглядит так:\nSELECT <Список Полей> FROM <Таблица> WHERE (Критерий) ORDER BY <Список Полей> ,где:\n·	SELECT — команда выбора записей из таблицы и вывода содержимого полей, имена которых указаны в списке;\n·	FROM — параметр команды, который определяет имя таблицы, из которой нужно сделать выборку;\n·	WHERE — параметр, который задает критерий выбора. В простейшем случае критерий — это инструкция проверки содержимого поля;\n·	ORDER BY - параметр, который задает условие, в соответствии с которым будут упорядочены записи, удовлетворяющие критерию запроса.\nВ данной работе возможно осуществлять поиск по 2 критериям: табельный номер, номер места. К примеру, рассмотрим поиск табельному номеру, запрос будет выглядеть следующим образом:\nIf Form2.ComboBox1.ItemIndex = 0 Then Begin\nWith Query1 Do Begin\nClose;\nSQL.Clear;\nSQL.Add(\'SELECT * FROM \":DBCadr:Podrarzel.db\" WHERE TabelNumber1 = \"\'+SQLData+\'\" Order by TabelNumber1\');\nOpen; end;\nIf Query1.RecordCount <> 0 Then Begin\nDataSource2.DataSet:=Query1;\nTable1.MasterSource:=DataSource2;\nTable1.MasterFields:=\'TabelNumber1\';\nTable3.MasterSource:=DataSource2;\nTable3.MasterFields:=\'MNumber1\';\nDBGrid1.ReadOnly:=True;\nDBGrid2.ReadOnly:=True;\nDBGrid3.ReadOnly:=True;\nDBNavigator1.Enabled:=False;\nDBNavigator3.Enabled:=False;\nend;\nIf Query1.RecordCount = 0 Then Begin\nDataSource2.DataSet:=Table2;\nMessageDlg(\'Данные не найдены!\', mtInformation, [mbOK], 0);\nTable1.MasterSource:=nil;\nTable3.MasterSource:=nil;\nend; end;\nДля запроса были использованы следующие методы:\no	Close – деактивирует запрос в качестве одной из мер предосторожности;\no	SQL.Clear – стирает любой предыдущий запрос;\no	SQL.Add – добавляет текст SQL-запроса;\no	Open – выполняет запрос и открываем набор данных\nСвяжем таблицы с помощью инспектора объектов, используя свойства компонента Table: MasterSource, для отображения результата поиска в других таблицах. Если данные не найдены, то:\nTable1.MasterSource:=nil\nАналогично формируются запросы и по другим критериям.\nДля сортировки используем переключатели RadioGroup. Первая группа переключателей определяет вид сортировки, то есть поле сортировки (например, Табельный номер и Фамилии). Вторая группа – направление сортировки, для этого при создании вторичных индексов указывался параметр – Descending.\nПрограммно сортировка выглядит следующим образом:\nIf (RadioButton2.Checked) and (RadioButton4.Checked) Then\nTable1.IndexName:=\'FamInd\';\nIf (RadioButton2.Checked) and (RadioButton5.Checked) Then\nTable1.IndexName:=\'FamIndDes\';\nIf (RadioButton1.Checked) and (RadioButton4.Checked) Then\nTable1.IndexName:=\'TabelNumberInd\';\nIf (RadioButton1.Checked) and (RadioButton5.Checked) Then\nTable1.IndexName:=\'TabelNumberIndDes\';\nТо есть при выборе переключателей “По табельному номеру” и “По возрастанию” свойству таблицы Table1 – IndexName присваивается значение TabelNumberInd, следовательно вторичный индекс TabelNumberInd будет использоваться для сортировки таблицы Table1. В результате таблица будет отсортирована по полю Табельный номер от меньшего значения к большему.\nДля каскадного удаления записей, то есть удаления записей из дочерней таблицы при удалении данных из главной таблицы, необходимо для компонента Table создать событие BeforeDelete в инспекторе объектов, в котором программно описываем следующие действия:\nTable2.MasterSource:=DataSource1;\nTable2.IndexName:=\'TabelNumber1\';\nTable2.MasterFields:=\'TabelNumber\';\nwith Table2 do begin\ndisableControls;\nfirst;\nwhile not EOF do\ndelete;\nenableControls; end;\nTable2.MasterSource:=nil;\nTable2.IndexName:=\'\';\nTable2.MasterFields:=\'\';\nТо есть связываем записи дочерней таблицы с записями главной через свойства компонента Table – MasterSource, MasterFields и через цикл while находим удаляемые записи в главной таблице и программным путем удаляем их в дочерней. Затем программно делаем независимое отображение таблиц.\n\n2.4 Тестирование приложения\n\nДля тестирования приложения выполним требуемые в качестве задания операции, а именно: добавление, удаление и поиск записей. В таблицу «Сотрудники» добавим запись. Результат можно увидеть на рисунке 2.4.1.\n\n\nРисунок 2.4.1 – Добавление записи\n\nТеперь удалим любую запись, например, только что созданную. Результат выполнения данной операции представлен на рисунке 2.4.2.\n\n\nРисунок 2.4.2 – Удаление записи\n\nТеперь произведём поиск по заданному критерию. Будем осуществлять поиск записи по номеру. В таблице «Подразделения» также отражена работа вычисляемых полей. Результаты поиска представлены на рисунке 2.4.3.\n\n\nРисунок 2.4.3 – Поиск по заданному критерию\n\nТеперь рассмотрим сортировки. К примеру, для таблицы «Сотрудники» отсортируем поля по возрастанию. Результат показан на рисунке 2.4.4.\n\n\nРисунок 2.4.4 – Сортировка\n\nТаким образом, мы убедились, что все функции, указанные в задании к курсовому проекту выполнены и работают корректно.\n\n2.5 Руководство пользователю\n\nГлавное окно программы изображено на рисунке 2.5.1. В окне видны три таблицы. Для добавления и удаления новых данных в таблицы используем DBNavigator. Для обеспечения удобства работы на форме располагаются кнопки, обеспечивающие поиск данных, обновление таблиц, сортировки и закрытие приложения.\n\n\nРисунок 2.5.1 – Главное окно программы\nПри нажатии кнопки «Поиск» появляется новая форма, представленная на рисунке 2.5.2, на которой можно выбрать критерий поиска.\n\n\nРисунок 2.5.2 – Форма для поиска\n\nДля осуществления поиска выбираем критерий в выпадающем списке. В поле для запроса вводим информацию, если данные введены неверно, появляется сообщение об ошибке. К примеру, осуществим поиск по критерию табельный номер. Способ заполнения формы и результат представлены соответственно на рисунках 2.5.3-2.5.4.\n\n\nРисунок 2.5.3 – Форма для поиска по заданному критерию\n\n\n\nРисунок 2.5.4 – Результат поиска\n\nТакже можно получить исходные данные по трём таблицам. Для этого необходимо нажать на кнопку «Обновить», расположенную на форме.\nДля выполнения сортировки в таблице «Рабочие места» установим переключатели как показано на рисунке 2.5.5 и нажмём кнопку «Ок».\n\n\nРисунок 2.5.5 – Критерии сортировки\n\nРезультат сортировки представлен на рисунке 2.5.6.\n\n\nРисунок 2.5.6 – Результат сортировки\n\nЗАКЛЮЧЕНИЕ\n\nДанный курсовой проект является актуальным и отвечает предъявленным к нему требованиям. Был разработан и написан, на языке программирования Borland Delphi 7, с использованием баз данных, программа, позволяющая осуществить поиск в имеющихся таблицах по заданному критерию, сортировку и осуществлять внесение изменений и добавление данных по мере необходимости.\n\nСПИСОК ИСПОЛЬЗОВАННЫХ ИСТОЧНИКОВ\n\n1.	Кононенко З. И. Конспект лекций по дисциплине «Технологии и системы программирования».\n2.	Архангельский А. Я. Программирование в Delphi 7. –М.:Бином, 2003. – 1152 с.: ил.\n3.	Фленов М. Е. Библия Delphi. –СПб.:БХВ-Петербург, 2004. – 880 с.: ил.\n\n\nПРИЛОЖЕНИЕ\n\nunit BD;\ninterface\nuses\nWindows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,\nDialogs, DB, StdCtrls, DBTables, ExtCtrls, DBCtrls, Grids, DBGrids, XPMan,\nButtons;\ntype\nTForm1 = class(TForm)\nDataSource1: TDataSource;\nDBGrid1: TDBGrid;\nDBNavigator1: TDBNavigator;\nTable1: TTable;\nTable1TabelNumber: TIntegerField;\nTable1Fam: TStringField;\nTable1Name: TStringField;\nTable1Otc: TStringField;\nTable1Birthday: TDateField;\nTable1Adres: TStringField;\nStaticText1: TStaticText;\nStaticText2: TStaticText;\nDataSource2: TDataSource;\nDBGrid2: TDBGrid;\nDBNavigator2: TDBNavigator;\nTable2: TTable;\nStaticText3: TStaticText;\nTable2PodrazName: TStringField;\nTable2TabelNumber1: TIntegerField;\nTable2MNumber1: TIntegerField;\nStaticText4: TStaticText;\nStaticText5: TStaticText;\nDataSource3: TDataSource;\nDBGrid3: TDBGrid;\nDBNavigator3: TDBNavigator;\nTable3: TTable;\nStaticText6: TStaticText;\nStaticText7: TStaticText;\nTable3MNumber: TIntegerField;\nTable3Doljnost: TStringField;\nTable3Oklad: TCurrencyField;\nGroupBox1: TGroupBox;\nRadioGroup1: TRadioGroup;\nRadioButton1: TRadioButton;\nRadioButton2: TRadioButton;\nRadioButton3: TRadioButton;\nGroupBox2: TGroupBox;\nRadioGroup3: TRadioGroup;\nRadioButton6: TRadioButton;\nRadioButton8: TRadioButton;\nRadioButton7: TRadioButton;\nRadioButton11: TRadioButton;\nGroupBox3: TGroupBox;\nRadioGroup5: TRadioGroup;\nRadioButton13: TRadioButton;\nRadioButton17: TRadioButton;\nRadioButton12: TRadioButton;\nXPManifest1: TXPManifest;\nBitBtn1: TBitBtn;\nBitBtn2: TBitBtn;\nBitBtn3: TBitBtn;\nGroupBox4: TGroupBox;\nRadioButton4: TRadioButton;\nRadioButton5: TRadioButton;\nGroupBox5: TGroupBox;\nRadioButton9: TRadioButton;\nRadioButton10: TRadioButton;\nGroupBox6: TGroupBox;\nRadioButton14: TRadioButton;\nRadioButton15: TRadioButton;\nBitBtn4: TBitBtn;\nBitBtn5: TBitBtn;\nBitBtn6: TBitBtn;\nQuery1: TQuery;\nQuery1PodrazName: TStringField;\nQuery1TabelNumber1: TIntegerField;\nQuery1MNumber1: TIntegerField;\nBitBtn7: TBitBtn;\nBitBtn8: TBitBtn;\nTable3Nadbavka: TFloatField;\nTable3Sum: TCurrencyField;\nTable2NumberPodraz: TIntegerField;\nQuery1NumberPodraz: TIntegerField;\nTable1Tel: TStringField;\nprocedure FormActivate(Sender: TObject);\nprocedure BitBtn2Click(Sender: TObject);\nprocedure BitBtn1Click(Sender: TObject);\nprocedure BitBtn3Click(Sender: TObject);\nprocedure BitBtn4Click(Sender: TObject);\nprocedure BitBtn5Click(Sender: TObject);\nprocedure BitBtn6Click(Sender: TObject);\nprocedure RadioButton1Click(Sender: TObject);\nprocedure RadioButton2Click(Sender: TObject);\nprocedure RadioButton7Click(Sender: TObject);\nprocedure RadioButton6Click(Sender: TObject);\nprocedure RadioButton11Click(Sender: TObject);\nprocedure RadioButton17Click(Sender: TObject);\nprocedure RadioButton12Click(Sender: TObject);\nprocedure RadioButton3Click(Sender: TObject);\nprocedure RadioButton8Click(Sender: TObject);\nprocedure RadioButton13Click(Sender: TObject);\nprocedure BitBtn8Click(Sender: TObject);\nprocedure BitBtn7Click(Sender: TObject);\nprocedure Table3CalcFields(DataSet: TDataSet);\nprocedure Table1BeforeDelete(DataSet: TDataSet);\nprocedure Table3BeforeDelete(DataSet: TDataSet);\nprivate\n{ Private declarations }\npublic\n{ Public declarations }\nend;\nvar\nForm1: TForm1;\nimplementation\nuses BDFind;\n{$R *.dfm}\nprocedure TForm1.FormActivate(Sender: TObject);\nbegin\nRadioButton3.Checked:=True;\nRadioButton8.Checked:=True;\nRadioButton13.Checked:=True;\nRadioButton4.Checked:=True;\nRadioButton9.Checked:=True;\nRadioButton14.Checked:=True;\nRadioButton4.Enabled:=False;\nRadioButton5.Enabled:=False;\nRadioButton9.Enabled:=False;\nRadioButton10.Enabled:=False;\nRadioButton14.Enabled:=False;\nRadioButton15.Enabled:=False;\nBitBtn7.Enabled:=False;\nend;\nprocedure TForm1.BitBtn2Click(Sender: TObject);\nlabel l;\nvar SQLData: String;\nbegin\nRadioButton3.Checked:=True;\nRadioButton8.Checked:=True;\nRadioButton13.Checked:=True;\nRadioButton1.Enabled:=False;\nRadioButton2.Enabled:=False;\nRadioButton3.Enabled:=False;\nRadioButton7.Enabled:=False;\nRadioButton6.Enabled:=False;\nRadioButton11.Enabled:=False;\nRadioButton8.Enabled:=False;\nRadioButton17.Enabled:=False;\nRadioButton12.Enabled:=False;\nRadioButton13.Enabled:=False;\nl: Form2.ShowModal;\nSQLData:=Form2.Edit1.Text;\nIf Form2.Edit1.Text = \'\' Then Begin\nMessageDlg(\'Не введены данные для поиска!\', mtWarning, [mbOK], 0); Goto l; end;\nIf Form2.ComboBox1.ItemIndex = 0 Then Begin\nWith Query1 Do Begin\nClose;\nSQL.Clear;\nSQL.Add(\'SELECT * FROM \":DBCadr:Podrarzel.db\" WHERE TabelNumber1 = \"\'+SQLData+\'\" Order by TabelNumber1\');\nOpen; end;\nIf Query1.RecordCount <> 0 Then Begin\nDataSource2.DataSet:=Query1;\nTable1.MasterSource:=DataSource2;\nTable1.MasterFields:=\'TabelNumber1\';\nTable3.MasterSource:=DataSource2;\nTable3.MasterFields:=\'MNumber1\';\nDBGrid1.ReadOnly:=True;\nDBGrid2.ReadOnly:=True;\nDBGrid3.ReadOnly:=True;\nDBNavigator1.Enabled:=False;\nDBNavigator3.Enabled:=False;\nend;\nIf Query1.RecordCount = 0 Then Begin\nDataSource2.DataSet:=Table2;\nMessageDlg(\'Данные не найдены!\', mtInformation, [mbOK], 0);\nTable1.MasterSource:=nil;\nTable3.MasterSource:=nil;\nRadioButton1.Enabled:=True;\nRadioButton2.Enabled:=True;\nRadioButton3.Enabled:=True;\nRadioButton7.Enabled:=True;\nRadioButton6.Enabled:=True;\nRadioButton11.Enabled:=True;\nRadioButton8.Enabled:=True;\nRadioButton17.Enabled:=True;\nRadioButton12.Enabled:=True;\nRadioButton13.Enabled:=True;\nend; end;\nIf Form2.ComboBox1.ItemIndex = 1 Then Begin\nWith Query1 Do Begin\nClose;\nSQL.Clear;\nSQL.Add(\'SELECT * FROM \":DBCadr:Podrarzel.db\" WHERE MNumber1 = \"\'+SQLData+\'\" Order by MNumber1\');\nOpen; end;\nIf Query1.RecordCount <> 0 Then Begin\nDataSource2.DataSet:=Query1;\nTable1.MasterSource:=DataSource2;\nTable1.MasterFields:=\'TabelNumber1\';\nTable3.MasterSource:=DataSource2;\nTable3.MasterFields:=\'MNumber1\';\nDBGrid1.ReadOnly:=True;\nDBGrid2.ReadOnly:=True;\nDBGrid3.ReadOnly:=True;\nDBNavigator1.Enabled:=False;\nDBNavigator3.Enabled:=False;\nend;\nIf Query1.RecordCount = 0 Then Begin\nDataSource2.DataSet:=Table2;\nMessageDlg(\'Данные не найдены!\', mtInformation, [mbOK], 0);\nTable1.MasterSource:=nil;\nTable3.MasterSource:=nil;\nRadioButton1.Enabled:=True;\nRadioButton2.Enabled:=True;\nRadioButton3.Enabled:=True;\nRadioButton7.Enabled:=True;\nRadioButton6.Enabled:=True;\nRadioButton11.Enabled:=True;\nRadioButton8.Enabled:=True;\nRadioButton17.Enabled:=True;\nRadioButton12.Enabled:=True;\nRadioButton13.Enabled:=True;\nend; end;\nend;\nprocedure TForm1.BitBtn1Click(Sender: TObject);\nbegin\nDBGrid1.ReadOnly:=False;\nDBGrid2.ReadOnly:=False;\nDBGrid3.ReadOnly:=False;\nTable1.MasterSource:=nil;\nTable3.MasterSource:=nil;\nDataSource2.DataSet:=Table2;\nDBNavigator1.Enabled:=True;\nDBNavigator3.Enabled:=True;\nRadioButton1.Enabled:=True;\nRadioButton2.Enabled:=True;\nRadioButton3.Enabled:=True;\nRadioButton7.Enabled:=True;\nRadioButton6.Enabled:=True;\nRadioButton11.Enabled:=True;\nRadioButton8.Enabled:=True;\nRadioButton17.Enabled:=True;\nRadioButton12.Enabled:=True;\nRadioButton13.Enabled:=True;\nend;\nprocedure TForm1.BitBtn3Click(Sender: TObject);\nbegin\nForm1.Close;\nend;\nprocedure TForm1.BitBtn4Click(Sender: TObject);\nbegin\nIf (RadioButton2.Checked) and (RadioButton4.Checked) Then\nTable1.IndexName:=\'FamInd\';\nIf (RadioButton2.Checked) and (RadioButton5.Checked) Then\nTable1.IndexName:=\'FamIndDes\';\nIf (RadioButton1.Checked) and (RadioButton4.Checked) Then\nTable1.IndexName:=\'TabelNumberInd\';\nIf (RadioButton1.Checked) and (RadioButton5.Checked) Then\nTable1.IndexName:=\'TabelNumberIndDes\';\nend;\nprocedure TForm1.BitBtn5Click(Sender: TObject);\nbegin\nIf (RadioButton7.Checked) and (RadioButton9.Checked) Then\nTable2.IndexName:=\'PodrazNameInd\';\nIf (RadioButton7.Checked) and (RadioButton10.Checked) Then\nTable2.IndexName:=\'PodrazNameIndDes\';\nIf (RadioButton6.Checked) and (RadioButton9.Checked) Then\nTable2.IndexName:=\'TabelNumber1\';\nIf (RadioButton6.Checked) and (RadioButton10.Checked) Then\nTable2.IndexName:=\'TabelNumber1Des\';\nIf (RadioButton11.Checked) and (RadioButton9.Checked) Then\nTable2.IndexName:=\'MNumber1\';\nIf (RadioButton11.Checked) and (RadioButton10.Checked) Then\nTable2.IndexName:=\'MNumber1Des\';\nend;\nprocedure TForm1.BitBtn6Click(Sender: TObject);\nbegin\nIf (RadioButton17.Checked) and (RadioButton14.Checked) Then\nTable3.IndexName:=\'MNumberInd\';\nIf (RadioButton17.Checked) and (RadioButton15.Checked) Then\nTable3.IndexName:=\'MNumberIndDes\';\nIf (RadioButton12.Checked) and (RadioButton14.Checked) Then\nTable3.IndexName:=\'DoljnostInd\';\nIf (RadioButton12.Checked) and (RadioButton15.Checked) Then\nTable3.IndexName:=\'DoljnostIndDes\';\nend;\nprocedure TForm1.RadioButton1Click(Sender: TObject);\nbegin\nRadioButton4.Enabled:=True;\nRadioButton5.Enabled:=True;\nBitBtn4.Enabled:=True;\nend;\nprocedure TForm1.RadioButton2Click(Sender: TObject);\nbegin\nRadioButton4.Enabled:=True;\nRadioButton5.Enabled:=True;\nBitBtn4.Enabled:=True;\nend;\nprocedure TForm1.RadioButton7Click(Sender: TObject);\nbegin\nRadioButton9.Enabled:=True;\nRadioButton10.Enabled:=True;\nBitBtn5.Enabled:=True;\nend;\nprocedure TForm1.RadioButton6Click(Sender: TObject);\nbegin\nRadioButton9.Enabled:=True;\nRadioButton10.Enabled:=True;\nBitBtn5.Enabled:=True;\nend;\nprocedure TForm1.RadioButton11Click(Sender: TObject);\nbegin\nRadioButton9.Enabled:=True;\nRadioButton10.Enabled:=True;\nBitBtn5.Enabled:=True;\nend;\nprocedure TForm1.RadioButton17Click(Sender: TObject);\nbegin\nRadioButton14.Enabled:=True;\nRadioButton15.Enabled:=True;\nBitBtn6.Enabled:=True;\nend;\nprocedure TForm1.RadioButton12Click(Sender: TObject);\nbegin\nRadioButton14.Enabled:=True;\nRadioButton15.Enabled:=True;\nBitBtn6.Enabled:=True;\nend;\nprocedure TForm1.RadioButton3Click(Sender: TObject);\nbegin\nTable1.IndexName:=\'\';\nRadioButton4.Checked:=True;\nRadioButton5.Checked:=False;\nRadioButton4.Enabled:=False;\nRadioButton5.Enabled:=False;\nBitBtn4.Enabled:=False;\nend;\nprocedure TForm1.RadioButton8Click(Sender: TObject);\nbegin\nTable2.IndexName:=\'\';\nRadioButton9.Checked:=True;\nRadioButton10.Checked:=False;\nRadioButton9.Enabled:=False;\nRadioButton10.Enabled:=False;\nBitBtn5.Enabled:=False;\nend;\nprocedure TForm1.RadioButton13Click(Sender: TObject);\nbegin\nTable3.IndexName:=\'\';\nRadioButton14.Checked:=True;\nRadioButton15.Checked:=False;\nRadioButton14.Enabled:=False;\nRadioButton15.Enabled:=False;\nBitBtn6.Enabled:=False;\nend;\nprocedure TForm1.BitBtn8Click(Sender: TObject);\nbegin\nForm1.Height:=571;\nBitBtn7.Enabled:=True;\nend;\nprocedure TForm1.BitBtn7Click(Sender: TObject);\nbegin\nForm1.Height:=827;\nBitBtn7.Enabled:=False;\nend;\nprocedure TForm1.Table3CalcFields(DataSet: TDataSet);\nbegin\nTable3Sum.Value:=Table3Oklad.Value+Table3Oklad.Value*Table3Nadbavka.Value/100;\nend;\nprocedure TForm1.Table1BeforeDelete(DataSet: TDataSet);\nbegin\nTable2.MasterSource:=DataSource1;\nTable2.IndexName:=\'TabelNumber1\';\nTable2.MasterFields:=\'TabelNumber\';\nwith Table2 do begin\ndisableControls;\nfirst;\nwhile not EOF do\ndelete;\nenableControls; end;\nTable2.MasterSource:=nil;\nTable2.IndexName:=\'\';\nTable2.MasterFields:=\'\';\nend;\nprocedure TForm1.Table3BeforeDelete(DataSet: TDataSet);\nbegin\nTable2.MasterSource:=DataSource3;\nTable2.IndexName:=\'MNumber1\';\nTable2.MasterFields:=\'MNumber\';\nwith Table2 do begin\ndisableControls;\nfirst;\nwhile not EOF do\ndelete;\nenableControls; end;\nTable2.MasterSource:=nil;\nTable2.IndexName:=\'\';\nTable2.MasterFields:=\'\';\nend;\nend.\nunit BDFind;\ninterface\nuses\nWindows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,\nDialogs, StdCtrls, Buttons;\ntype\nTForm2 = class(TForm)\nGroupBox1: TGroupBox;\nLabel1: TLabel;\nComboBox1: TComboBox;\nLabel2: TLabel;\nEdit1: TEdit;\nBitBtn1: TBitBtn;\nprocedure FormActivate(Sender: TObject);\nprivate\n{ Private declarations }\npublic\n{ Public declarations }\nend;\nvar\nForm2: TForm2;\nimplementation\nuses BD;\n{$R *.dfm}\nprocedure TForm2.FormActivate(Sender: TObject);\nbegin\nEdit1.Clear;\nEdit1.SetFocus;\nend;\nend.\nРазмещено на Allbest.ru','2020-11-17',3,6);
/*!40000 ALTER TABLE `document` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `info`
--

DROP TABLE IF EXISTS `info`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `info` (
  `id` int NOT NULL AUTO_INCREMENT,
  `user_name` varchar(200) NOT NULL,
  `surname` varchar(200) NOT NULL,
  `birthday` date DEFAULT NULL,
  `phone` varchar(45) DEFAULT NULL,
  `email` varchar(100) DEFAULT NULL,
  `users_id` int NOT NULL,
  PRIMARY KEY (`id`),
  KEY `fk_info_users1_idx` (`users_id`),
  CONSTRAINT `fk_info_users1` FOREIGN KEY (`users_id`) REFERENCES `users` (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `info`
--

LOCK TABLES `info` WRITE;
/*!40000 ALTER TABLE `info` DISABLE KEYS */;
INSERT INTO `info` VALUES (1,'Крутой','Админ',NULL,NULL,NULL,3),(2,'автор','проекта',NULL,NULL,NULL,5),(3,'122','33','2020-11-17','eef','a',6);
/*!40000 ALTER TABLE `info` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `users`
--

DROP TABLE IF EXISTS `users`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `users` (
  `id` int NOT NULL AUTO_INCREMENT,
  `user_login` varchar(200) NOT NULL,
  `user_password` varchar(200) NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `user_login_UNIQUE` (`user_login`)
) ENGINE=InnoDB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `users`
--

LOCK TABLES `users` WRITE;
/*!40000 ALTER TABLE `users` DISABLE KEYS */;
INSERT INTO `users` VALUES (3,'admin','admin'),(5,'author','project'),(6,'assassin','demon');
/*!40000 ALTER TABLE `users` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2020-11-17  4:06:30
